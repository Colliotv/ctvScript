#ifndef ASTnode_h__
# define ASTnode_h__
# define INCLUDED_FROM_ASTNODE

# include <map>

# include "syntax/dictionnary.h"
/*
 * Here is defined the majority of AST nodes
 * implemntation are done in src
 */
namespace ctvscript {
  namespace AST {
    /*
     * This interface will premit easier tree/list constructing
     */
    class node {
    public:
      class syntax {
      private:
	const std::string	m_file_line;
	const std::size_t	m_column;
	const std::size_t	m_line;

      public:
	syntax(const std::string&, std::size_t, std::size_t);
      };
      static const parser::syntax::identifier syntax_identifier = parser::syntax::identifier::unknown;

    public:
      node(const std::string&, const node::syntax&);

    public:
      virtual const node::syntax get_file_syntax() { return m_syntax; }
      virtual const std::string  get_syntax() { return m_string_syntax; }

    private:
      const std::string		m_string_syntax;
      const node::syntax	m_syntax;
    };

    /*
     * A key word is language specs
     */
    namespace keyword {
      #include "nodes/var.h"
      class Var;	//: AST::node{};

      #include "nodes/fun.h"
      class Fun;	//: AST::node{};

      #include "nodes/if_else.h"
      class If;		//: AST::node{}; 
      class Else;	//: AST::node{}; 

      #include "nodes/return.h"
      class Return;	//: AST::node{};

      #include "nodes/typedef.h"
      class Typedef;	//: AST::node{};

      #include "nodes/import.h"
      class Import;	//: AST::node{};

      #include "nodes/class.h"
      class Namespace;
      class Class;
      class Public;
      class Private;

    };

    /*
     * Symbols
     */
    namespace symbol {
      #include "nodes/reference_symbol.h"
      class Reference;

      #include "nodes/semicolon.h"
      class Semicolon;	 //: AST::node{};

      #include "nodes/colon.h"
      class Colon;	 //: AST::node{};

      #include "nodes/comma.h"
      class Comma;

      #include "nodes/parenthesis.h"
      class Bparenthesis;//: AST::node{};
      class Eparenthesis;//: AST::node{};

      #include "nodes/brackets.h"
      class Bbracket;	 //: AST::node{};
      class Ebracket;	 //: AST::node{};

      #include "nodes/squarebrackets.h"
      class Bsqbracket; //: AST::node{};
      class Esqbracket; //: AST::node{};

      #include "nodes/star.h"
      class Star;	//: AST::node{};
    };

    /*
     * Operands
     */
    namespace operands {
      #include "nodes/scope_resolution.h"
      class ScopeResolution;

      #include "nodes/allocators_operands.h"
      class New;	 //: AST::node{};
      class Delete;	 //: AST::node{};

      #include "nodes/binary_operators.h"
      class Binary_and;	 //: AST::node{};
      class Binary_or;	 //: AST::node{};
      class Binary_left_shift;	 //: AST::node{};
      class Binary_right_shift;	 //: AST::node{};

      #include "nodes/assignement.h"
      class Assignement;

      #include "nodes/mathematical_operators.h"
      class Addition;		//: AST::node{};
      class Substraction;	//: AST::node{};
      class Division;		//: AST::node{};
      class Modulo;		//: AST::node{};
      class Decrement;		//: AST::node{};
      class Increment;		//: AST::node{};

      #include "nodes/comparison.h"
      class Or;			//: AST::node{};
      class And;		//: AST::node{};

      #include "nodes/bool_operators.h"
      class Inferior;		//: AST::node{};
      class Inferior_equal;	//: AST::node{};
      class Superior;		//: AST::node{};
      class Superior_equal;	//: AST::node{};
      class Equality;		//: AST::node{};
    };

    /*
     * Values
     */
    namespace values {
      #include "nodes/types_modifier.h"
      class Const;
      class Static;

      #include "nodes/unspecified_typeid.h"
      class Unspecified_typeid;	 //: AST::node{};

      #include "nodes/string_litteral.h"
      class String;
      class Char;

      #include "nodes/floating.h"
      class Floating;

      #include "nodes/integer.h"
      class Integer;

    }

    /*
     * Class generated by line::on_success methode
     */
    namespace final {
      #include "nodes/scoped_id.h"
      class ScopedId;

      #include "nodes/function_definition.h"
      class Function;

      #include "nodes/type_definition.h"
      class Type;

      #include "nodes/ArgumentList.h"
      class ArgumentsList;
    }

# define SYNTAX_BUILDABLE_NODE_LIST					\
    keyword::Var,							\
      keyword::Fun,							\
      keyword::If, keyword::Else,					\
      keyword::Return,							\
      keyword::Import,							\
      keyword::Namespace,						\
      keyword::Class, keyword::Public, keyword::Private,		\
      symbol::Semicolon,						\
      symbol::Colon,							\
      symbol::Star,							\
      symbol::Bparenthesis, symbol::Eparenthesis,			\
      symbol::Bbracket, symbol::Ebracket,				\
      symbol::Bsqbracket, symbol::Esqbracket,				\
      operands::New, operands::Delete,					\
      operands::Binary_and, operands::Binary_or,			\
      operands::Binary_left_shift, operands::Binary_right_shift,	\
      operands::Assignement,						\
      operands::Addition, operands::Substraction,			\
      operands::Division, operands::Modulo,				\
      operands::Decrement, operands::Increment,				\
      operands::Or, operands::And,					\
      operands::Inferior, operands::Inferior_equal,			\
      operands::Superior, operands::Superior_equal,			\
      operands::Equality,						\
      operands::ScopeResolution,					\
      values::Unspecified_typeid,					\
      values::Const, values::Static,					\
      values::String, values::Char,					\
      values::Floating, values::Integer

    /*
     * The Factory help in two way: 
		-> Parsing
		-> [...]
     */
    class factory {
    private:
      static const std::map<parser::syntax::identifier, std::function<AST::node*(const std::string&, const node::syntax&)> >
	m_syntax_ASTallocator;

    public:
      static AST::node* create_node_by_syntax(parser::syntax::identifier, const std::string&, const node::syntax&);
    };
  };
};

#undef INCLUDED_FROM_ASTNODE
#endif
