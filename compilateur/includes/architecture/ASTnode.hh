#ifndef ASTnode_h__
# define ASTnode_h__
# define INCLUDED_FROM_ASTNODE

# include <map>

# include "syntax/dictionnary.hh"

# include "data/derived_types.hh"

/*
 * Here is defined the majority of AST nodes
 * implemntation are done in src
 */
namespace ctvscript {
  namespace AST {
    /*
     * This interface will premit easier tree/list constructing
     */
    class node {
    public:
      class syntax {
      private:
	const std::string	m_file_line;
	const std::size_t	m_column;
	const std::size_t	m_line;

      public:
	syntax(const std::string&, std::size_t, std::size_t);

      public:
	std::string		get_file_line() const;
	std::size_t		get_column() const;
	std::size_t		get_line() const;
      };
      static const parser::syntax::identifier syntax_identifier = parser::syntax::identifier::unknown;

    public:
      node(const std::string&, const node::syntax&);

    public:
      virtual const node::syntax get_file_syntax() { return m_syntax; }
      virtual const std::string  get_syntax() { return m_string_syntax; }

    private:
      const std::string		m_string_syntax;
      const node::syntax	m_syntax;
    };

    /*
     * A key word is language specs
     */
    namespace keyword {
      #include "nodes/keyword/var.hh"
      class Var;	//: AST::node{};

      #include "nodes/keyword/fun.hh"
      class Fun;	//: AST::node{};

      #include "nodes/keyword/if_else.hh"
      class If;		//: AST::node{}; 
      class Else;	//: AST::node{}; 

      #include "nodes/keyword/return.hh"
      class Return;	//: AST::node{};

      #include "nodes/keyword/typedef.hh"
      class Typedef;	//: AST::node{};

      #include "nodes/keyword/import.hh"
      class Import;	//: AST::node{};

      #include "nodes/keyword/class.hh"
      class Namespace;
      class Class;
      class Public;
      class Private;

    };

    /*
     * Symbols
     */
    namespace symbol {
      #include "nodes/symbol/reference_symbol.hh"
      class Reference;

      #include "nodes/symbol/semicolon.hh"
      class Semicolon;	 //: AST::node{};

      #include "nodes/symbol/colon.hh"
      class Colon;	 //: AST::node{};

      #include "nodes/symbol/comma.hh"
      class Comma;

      #include "nodes/symbol/parenthesis.hh"
      class Bparenthesis;//: AST::node{};
      class Eparenthesis;//: AST::node{};

      #include "nodes/symbol/brackets.hh"
      class Bbracket;	 //: AST::node{};
      class Ebracket;	 //: AST::node{};

      #include "nodes/symbol/squarebrackets.hh"
      class Bsqbracket; //: AST::node{};
      class Esqbracket; //: AST::node{};

      #include "nodes/symbol/star.hh"
      class Star;	//: AST::node{};
    };

    /*
     * Operands
     */
    namespace operands {
      #include "nodes/operands/scope_resolution.hh"
      class ScopeResolution;

      #include "nodes/operands/allocators_operands.hh"
      class New;	 //: AST::node{};
      class Delete;	 //: AST::node{};

      #include "nodes/operands/binary_operators.hh"
      class Binary_and;	 //: AST::node{};
      class Binary_or;	 //: AST::node{};
      class Binary_left_shift;	 //: AST::node{};
      class Binary_right_shift;	 //: AST::node{};

      #include "nodes/operands/assignement.hh"
      class Assignement;

      #include "nodes/operands/mathematical_operators.hh"
      class Addition;		//: AST::node{};
      class Substraction;	//: AST::node{};
      class Division;		//: AST::node{};
      class Modulo;		//: AST::node{};
      class Decrement;		//: AST::node{};
      class Increment;		//: AST::node{};

      #include "nodes/operands/comparison.hh"
      class Or;			//: AST::node{};
      class And;		//: AST::node{};

      #include "nodes/operands/bool_operators.hh"
      class Inferior;		//: AST::node{};
      class Inferior_equal;	//: AST::node{};
      class Superior;		//: AST::node{};
      class Superior_equal;	//: AST::node{};
      class Equality;		//: AST::node{};
    };

    /*
     * Values
     */
    namespace values {
      #include "nodes/values/types_modifier.hh"
      class Const;
      class Static;

      #include "nodes/values/unspecified_typeid.hh"
      class Unspecified_typeid;	 //: AST::node{};

      #include "nodes/values/string_litteral.hh"
      class String;
      class Char;

      #include "nodes/values/floating.hh"
      class Floating;

      #include "nodes/values/integer.hh"
      class Integer;

    }

    /*
     * Class generated by line::on_success methode
     */
    namespace final {
      #include "nodes/final/scoped_id.hh"
      class ScopedId;

      #include "nodes/final/scoped_type.hh"
      class ScopedType;

      #include "nodes/final/function_prototype.hh"
      class FunctionPrototype;

      #include "nodes/final/function_forward_declaration.hh"
      class FunctionForwardDeclaration;

      #include "nodes/final/type_definition.hh"
      class Type;

      #include "nodes/final/argumentList.hh"
      class ArgumentsList;
    }

# define SYNTAX_BUILDABLE_NODE_LIST					\
    keyword::Var,							\
      keyword::Fun,							\
      keyword::If, keyword::Else,					\
      keyword::Return,							\
      keyword::Import,							\
      keyword::Namespace,						\
      keyword::Class, keyword::Public, keyword::Private,		\
      symbol::Semicolon,						\
      symbol::Colon,							\
      symbol::Star,							\
      symbol::Comma,							\
      symbol::Bparenthesis, symbol::Eparenthesis,			\
      symbol::Bbracket, symbol::Ebracket,				\
      symbol::Bsqbracket, symbol::Esqbracket,				\
      operands::New, operands::Delete,					\
      operands::Binary_and, operands::Binary_or,			\
      operands::Binary_left_shift, operands::Binary_right_shift,	\
      operands::Assignement,						\
      operands::Addition, operands::Substraction,			\
      operands::Division, operands::Modulo,				\
      operands::Decrement, operands::Increment,				\
      operands::Or, operands::And,					\
      operands::Inferior, operands::Inferior_equal,			\
      operands::Superior, operands::Superior_equal,			\
      operands::Equality,						\
      operands::ScopeResolution,					\
      values::Unspecified_typeid,					\
      values::Const, values::Static,					\
      values::String, values::Char,					\
      values::Floating, values::Integer

    /*
     * The Factory help in two way: 
		-> Parsing
		-> [...]
     */
    class factory {
    private:
      static const std::map<parser::syntax::identifier, std::function<AST::node*(const std::string&, const node::syntax&)> >
	m_syntax_ASTallocator;

    public:
      static AST::node* create_node_by_syntax(parser::syntax::identifier, const std::string&, const node::syntax&);
    };
  };
};

#undef INCLUDED_FROM_ASTNODE
#endif
